[#authorization]

Welcome to the supplemental lab of this workshop. 

=== Keycloak Authorization and Policy Enforcer

The terminology:

From a design perspective, Authorization Services is based on a well-defined set of authorization patterns providing these capabilities:

Policy Administration Point (PAP)

Provides a set of UIs based on the Keycloak Administration Console to manage resource servers, resources, scopes, permissions, and policies. Part of this is also accomplished remotely through the use of the Protection API.

Policy Decision Point (PDP)

Provides a distributable policy decision point to where authorization requests are sent and policies are evaluated accordingly with the permissions being requested. For more information, see Obtaining Permissions.

Policy Enforcement Point (PEP)

Provides implementations for different environments to actually enforce authorization decisions at the resource server side. Keycloak provides some built-in Policy Enforcers.

Policy Information Point (PIP)

Being based on Keycloak Authentication Server, you can obtain attributes from identities and runtime environment during the evaluation of authorization policies.

image::auth-arch-overview.png[auth-arch-overview, 900]

The simplified pattern can look like:

image::pep-pattern-diagram.png[pep-pattern-diagram.png, 600]

for the purpose of this workshop:

<1> the client will be the `curl` utility trying to access the application
<2> the protected resource is the API exposed by the book application
<3> the PEP will be application configuration to delegated the authorization decision to Keycloak
<4> the PDP is Keycloak (RH SSO)

=== Step 1: Enable Authorization services

For this workshop, we will use a custom policy.

the custom policy looks like this:

[source,javascript,role="copypaste"]
----
var context = $evaluation.getContext();
var identity = context.getIdentity();
var attributes = identity.getAttributes();
var email = attributes.getValue('email').asString(0);

if (email.endsWith('@redhat.com')) {
    $evaluation.grant();
}
----

It gets the email attributes from the token associated with the user and returns a positive evaluation when the email domain is redhat.com

This policy is packaged in another Keycloak extension that we must add to our keycloak server

The jar file was build previously and for convenience stored in a GIT responsitory. We will use the operator to load these extensions into our keycloak server.

[#custom-stream]
[source,bash,subs="+macros,+attributes"]
----
# edit the keycloak custom resource to instruct the operator to load extensions
oc get keycloak 
oc edit keycloak example-keycloak
----

add the following extension:

[source,bash,subs="+macros,+attributes"]
----
spec:
  extensions:
  - https://gitea-gitea.{{ ROUTE_SUBDOMAIN }}/keycloak/extensions/raw/branch/main/themes.jar
  - https://gitea-gitea.{{ ROUTE_SUBDOMAIN }}/keycloak/extensions/raw/branch/main/magic-link.jar
  - https://gitea-gitea.{{ ROUTE_SUBDOMAIN }}/keycloak/extensions/raw/branch/main/authz-js-policies.jar
----


Lets first start by configuration our PDP (RH SSO).
Using the RH SSO Console.

<1> Realms > Quarkus
<2> Clients > backend-service
<3> Toggle on 'Authorization Enabled'
<4> Click on 'Save' at the bottom of the page
<5> This should activate the 'Authorization' tab

image::keycloak-client-authz.png[keycloak-client-authz, 900]

We will now configure authorization services for the backend-service client

First, lets create the scopes we need to protect the resources. In OIDC terminology, scopes usually represent the actions that can be performed on a resource, but they are not limited to that. You can also use scopes to represent one or more attributes within a resource.
Lets create the following scope:

<1> Authorization Tab > Scope > `Create` button
<2> create - that we will later map to the book creation API
<3> view - for everything else

image::keycloak_scopes.png[keycloak_scopes, 900]


Next, we will create the resource. In OIDC terminology, a resource can be a web page, a RESTFul resource, a file in your file system, a bean, and so on. They can represent a group of resources (just like a Class in Java) or they can represent a single and specific resource.

<1> Authorization Tab > Resources > 'create' button
<2> Enter the resource name, url and type
<3> Associate the scopes created above with the resources and click on the `save` button

We have now defined that the books endpoint of our API offers two different actions: create and view

image::keycloak_resources.png[keycloak_resources, 900]


In the next step we will create a policy that will be used to make an enforcement decision. The policy has been previously loaded, but it needs to be enabled on the OIDC backend-service client.

<1> Authorization Tab > Policies > 'create' button
<2> Select 'email match domain' policy.

image::keycloak_policy.png[keycloak_policy, 900]

You can look at the policy in the RH SSO console, you will see the code that was loaded using the extension capability of Keycloak

The final step is to configuration the permissions on the resources and scopes using the policies that we have enabled.

<1> Authorization Tab > permission > 'create' button
<2> Fill out the form and associate the create scope to the `email match domain` policy.
<3> click save

image::keycloak_create_permission.png[keycloak_create_permission, 900]

Repeat for the view scope but used the `default` policy. Everyone with a valid token will be granted access to view resources

image::keycloak_view_permission.png[keycloak_view_permission, 900]

Now, go the Users menu and update the `Alice` user with an email outside the redhat.com domain.
For example:

image::keycloak_alice_config.png[keycloak_alice_config, 900]



=== Step 2: Configure the application

Lets run this command in the `CodeReady Terminal`. Make sure you are in the project directory crud-oidc when you do this.

[source,sh,role="copypaste"]
----
mvn quarkus:add-extension -Dextensions='keycloak-authorization' 
----

This extension will add the Policy Decision Point (PDP) capability to your Quarkus application.  

Now, we must configure the PDP and the API we want to protect. 

[source, shell]
----
#enable policy enforcement
quarkus.keycloak.policy-enforcer.enable=true

#don't enforce policies on health check performed by Kubernetes
quarkus.keycloak.policy-enforcer.paths.1.path=/q/health/*
quarkus.keycloak.policy-enforcer.paths.1.enforcement-mode=DISABLED

#any access to the /books api using GET method needs to evaluate against the view scope
quarkus.keycloak.policy-enforcer.paths.2.path=/books
quarkus.keycloak.policy-enforcer.paths.2.methods.1.method=GET
quarkus.keycloak.policy-enforcer.paths.2.methods.1.scopes=view

#any access to the /books api using GET method needs to evaluate against the create scope
quarkus.keycloak.policy-enforcer.paths.2.methods.2.method=POST
quarkus.keycloak.policy-enforcer.paths.2.methods.2.scopes=create
----

add the above section to the 'application.properties' file. 
No code change is necessary. We will redeploy the application


[source,sh,role="copypaste"]
----
mvn clean compile package -Dquarkus.kubernetes.deploy=true
----

Wait for the application to redeploy. You can use the following command to monitor the activity:

[source,sh,role="copypaste"]
----
oc get pods -w
----


=== Step 3: Test the Policy Enforcer

To start with lets authenticate with our user Alice 

As a first we need to first authenticate with SSO to ensure we have a valid token to hit our backend service. This applies to any service that will hit our end point. In the following command we our sending a request to SSO for the realm quarkus to authenticate with `username=alice` and we store the resulting token into access_token on our console as an environment variable so we can reuse it in our books end point requests. 

[source,sh,role="copypaste"]
----
 export access_token=$(\
    curl --insecure -X POST https://keycloak-{{ USER_ID }}-keycloak.{{ ROUTE_SUBDOMAIN }}/auth/realms/quarkus/protocol/openid-connect/token \
    --user backend-service:secret \
    -H 'content-type: application/x-www-form-urlencoded' \
    -d 'username=alice&password=alice&grant_type=password' | jq --raw-output '.access_token' \
 )
----

Now lets try to curl our endpoints again but this time with the addition of `Authentication: Bearer token`. This will add the our authentication token for user alice into our request.

[source,sh]
----
# Gets all books
curl -X GET http://crud-oidc-{{ USER_ID }}-keycloak.{{ ROUTE_SUBDOMAIN }}/books -H "Authorization: Bearer "$access_token -v

# Create a new book
curl -X POST -H 'Content-Type: application/json' http://crud-oidc-{{ USER_ID }}-keycloak.{{ ROUTE_SUBDOMAIN }}/books -d @temp.json -H "Authorization: Bearer "$access_token -v
----

The second query should return a 403 (Forbidden) error. Since Alice email is not in the redhat.com domain.

Let's fix that.

In the Red Hat SSO console, edit the Alice user and set her email to 'alice@redhat.com'

Since the attributes are part of the token, we need to obtain a new access_token.

[source,sh,role="copypaste"]
----
 export access_token=$(\
    curl --insecure -X POST https://keycloak-{{ USER_ID }}-keycloak.{{ ROUTE_SUBDOMAIN }}/auth/realms/quarkus/protocol/openid-connect/token \
    --user backend-service:secret \
    -H 'content-type: application/x-www-form-urlencoded' \
    -d 'username=alice&password=alice&grant_type=password' | jq --raw-output '.access_token' \
 )
----

Now, the POST request should be successful

[source,sh]
----
# Create a new book
curl -X POST -H 'Content-Type: application/json' http://crud-oidc-{{ USER_ID }}-keycloak.{{ ROUTE_SUBDOMAIN }}/books -d @temp.json -H "Authorization: Bearer "$access_token -v
----
